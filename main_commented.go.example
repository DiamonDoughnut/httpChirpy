// Package main implements a REST API server for the Chirpy social media platform.
// This server provides endpoints for user management, authentication, and chirp (message) operations.
// It uses PostgreSQL for data persistence and JWT tokens for authentication.
//
// PRODUCTION CONSIDERATIONS:
// - Remove or secure the /admin/reset endpoint (destructive operation)
// - Implement proper logging with structured logs (JSON format)
// - Add rate limiting middleware to prevent abuse
// - Use environment-specific configuration management
// - Implement proper database connection pooling and health checks
// - Add request timeout and context cancellation handling
// - Consider using a proper router like gorilla/mux or gin for better middleware support
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"sync/atomic"
	"time"

	"github.com/diamondoughnut/httpChirpy/internal/auth"
	"github.com/diamondoughnut/httpChirpy/internal/database"
	"github.com/google/uuid"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

// apiConfig holds the application's configuration and shared state.
// This struct is passed to all HTTP handlers to provide access to:
// - Database connection for data operations
// - JWT secret key for token validation
// - Platform mode for environment-specific features
// - Hit counter for basic analytics
//
// PRODUCTION NOTE: The userId field creates stateful behavior which is problematic
// in multi-instance deployments. Consider removing this and extracting user ID
// from JWT tokens in each request instead.
type apiConfig struct {
	fileserverHits  atomic.Int32          // Thread-safe counter for tracking static file requests
	databaseQueries *database.Queries     // Database query interface generated by sqlc
	platform        string                // Environment mode ("dev" or "prod")
	secretKey       string                // JWT signing secret loaded from environment
	userId          uuid.UUID             // Current user ID (stateful, should be removed in production)
}

// User represents the user data structure returned in API responses.
// This struct is used for JSON serialization in login, registration, and user update endpoints.
// The Token and RefreshToken fields are only populated during authentication flows.
//
// PRODUCTION NOTE: Consider separating this into different structs for different use cases
// (e.g., UserResponse, LoginResponse) to avoid exposing unnecessary fields.
type User struct {
	ID           uuid.UUID `json:"id"`            // Unique user identifier
	CreatedAt    time.Time `json:"created_at"`    // Account creation timestamp
	UpdatedAt    time.Time `json:"updated_at"`    // Last account modification timestamp
	Email        string    `json:"email"`         // User's email address (unique)
	Token        string    `json:"token"`         // JWT access token (short-lived)
	RefreshToken string    `json:"refresh_token"` // Refresh token (long-lived)
}

// main initializes and starts the HTTP server.
// It loads configuration from environment variables, establishes database connection,
// sets up routing, and starts listening for requests on port 8080.
// The server will run until terminated or a fatal error occurs.
//
// PRODUCTION IMPROVEMENTS:
// - Add graceful shutdown handling (SIGTERM/SIGINT)
// - Implement health checks for dependencies (database, external services)
// - Add structured logging with correlation IDs
// - Configure proper timeouts (read, write, idle)
// - Add metrics collection (Prometheus, DataDog, etc.)
func main() {
	// Load environment variables from .env file (development convenience)
	// PRODUCTION: Use proper configuration management (Kubernetes secrets, AWS Parameter Store, etc.)
	godotenv.Load()

	// Extract required configuration from environment
	dbURL := os.Getenv("DB_URL")           // PostgreSQL connection string
	platform := os.Getenv("PLATFORM")     // "dev" or "prod" mode
	secretKey := os.Getenv("JWT_SECRET_KEY") // Secret for JWT token signing

	// PRODUCTION: Add validation for required environment variables
	if dbURL == "" || secretKey == "" {
		log.Fatal("Required environment variables not set")
	}

	// Establish database connection using PostgreSQL driver
	// PRODUCTION: Configure connection pooling, timeouts, and retry logic
	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close() // Ensure connection is closed on exit

	// Test database connectivity
	if err := db.Ping(); err != nil {
		log.Fatal("Database connection failed:", err)
	}

	// Initialize database query interface (generated by sqlc)
	dbQueries := database.New(db)

	// Create application configuration with all dependencies
	apiCfg := &apiConfig{
		databaseQueries: dbQueries,
		platform:        platform,
		secretKey:       secretKey,
	}

	// Set up HTTP router with all endpoints
	mux := http.NewServeMux()

	// Static file serving with hit tracking middleware
	// PRODUCTION: Use a CDN or dedicated static file server (nginx, Apache)
	mux.Handle("/app/", http.StripPrefix("/app", apiCfg.middlewareMetricsInc(http.FileServer(http.Dir(".")))))

	// Public API endpoints (no authentication required)
	mux.HandleFunc("GET /api/healthz", handlerHealthz)                    // Health check
	mux.HandleFunc("POST /api/users", apiCfg.handlerRegister)             // User registration
	mux.HandleFunc("POST /api/login", apiCfg.handlerLogin)                // User authentication

	// Protected API endpoints (require JWT authentication)
	mux.HandleFunc("POST /api/chirps", apiCfg.handlerCreateChirp)         // Create new chirp
	mux.HandleFunc("GET /api/chirps", apiCfg.handlerGetChirps)            // List all chirps
	mux.HandleFunc("GET /api/chirps/{chirpID}", apiCfg.handlerGetChirpById) // Get specific chirp
	mux.HandleFunc("PUT /api/users", apiCfg.handlerPutUsers)              // Update user data
	mux.HandleFunc("DELETE /api/chirps/{chirpID}", apiCfg.handlerDeleteChirp) // Delete chirp

	// Token management endpoints
	mux.HandleFunc("POST /api/refresh", apiCfg.handlerRefresh)            // Refresh JWT token
	mux.HandleFunc("POST /api/revoke", apiCfg.handlerRevoke)              // Revoke refresh token

	// Administrative endpoints
	// PRODUCTION: Secure these endpoints with proper authentication and authorization
	mux.HandleFunc("GET /admin/metrics", apiCfg.handlerMetrics)           // View analytics
	mux.HandleFunc("POST /admin/reset", apiCfg.handlerReset)              // Reset system state (DANGEROUS)

	// Configure HTTP server
	// PRODUCTION: Add timeouts, TLS configuration, and proper error handling
	srv := http.Server{
		Addr:         ":8080",        // Listen on port 8080
		Handler:      mux,            // Use our configured router
		ReadTimeout:  15 * time.Second, // Prevent slow client attacks
		WriteTimeout: 15 * time.Second, // Prevent slow response attacks
		IdleTimeout:  60 * time.Second, // Keep-alive timeout
	}

	log.Printf("Server starting on %s", srv.Addr)
	// Start server (blocks until error or termination)
	// PRODUCTION: Implement graceful shutdown
	log.Fatal(srv.ListenAndServe())
}

// handlerHealthz provides a simple health check endpoint.
// This endpoint is used by load balancers, monitoring systems, and deployment tools
// to verify that the server is running and responsive.
//
// PRODUCTION IMPROVEMENTS:
// - Add dependency health checks (database, external APIs)
// - Return structured JSON with detailed status information
// - Include version information and build metadata
// - Add caching headers to reduce load
//
// Returns: 200 OK with "OK" text body
func handlerHealthz(w http.ResponseWriter, r *http.Request) {
	w.Header().Add("Content-Type", "text/plain; charset=utf-8")
	w.WriteHeader(200)
	w.Write([]byte("OK"))
}

// handlerMetrics displays basic analytics for administrators.
// Shows the total number of static file requests served by the application.
// This is a simple implementation for demonstration - production systems would
// typically use dedicated analytics tools like Prometheus, DataDog, etc.
//
// PRODUCTION IMPROVEMENTS:
// - Add proper authentication/authorization
// - Use structured metrics format (JSON)
// - Implement proper metrics collection system
// - Add more meaningful metrics (response times, error rates, etc.)
//
// Returns: HTML page with hit counter
func (cfg *apiConfig) handlerMetrics(w http.ResponseWriter, r *http.Request) {
	w.Header().Add("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(200)
	w.Write([]byte(fmt.Sprintf("<html><body><h1>Welcome, Chirpy Admin</h1><p>Chirpy has been visited %d times!</p></body></html>", cfg.fileserverHits.Load())))
}

// handlerReset provides a development endpoint to reset system state.
// WARNING: This endpoint deletes ALL users from the database and resets hit counter.
// This is intended for development/testing only and should be removed or protected in production.
//
// PRODUCTION CONSIDERATIONS:
// - Remove this endpoint entirely in production
// - If data reset is needed, implement proper administrative tools
// - Add authentication and authorization
// - Add confirmation mechanisms to prevent accidental data loss
// - Consider soft deletes instead of hard deletes
func (cfg *apiConfig) handlerReset(w http.ResponseWriter, r *http.Request) {
	// PRODUCTION: Add authentication check here
	// if !isAdmin(r) { return 403 }

	// Delete all users from database (DESTRUCTIVE OPERATION)
	err := cfg.databaseQueries.DeleteUsers(r.Context())
	if err != nil {
		log.Printf("Error deleting users: %s", err.Error())
		marshallError(w, err, 500)
		return
	}

	// Reset hit counter to zero
	cfg.fileserverHits.Store(0)

	w.Header().Add("Content-Type", "text/plain; charset=utf-8")
	w.WriteHeader(200)
	w.Write([]byte("Hits reset to 0"))
}

// middlewareMetricsInc is HTTP middleware that tracks request counts.
// This middleware wraps static file serving to count how many times files are accessed.
// Uses atomic operations to ensure thread-safe counting in concurrent environments.
//
// PRODUCTION IMPROVEMENTS:
// - Use proper metrics collection (Prometheus counters)
// - Add request duration tracking
// - Include response status code metrics
// - Add request path and method tracking
// - Consider sampling for high-traffic applications
func (cfg *apiConfig) middlewareMetricsInc(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Atomically increment hit counter (thread-safe)
		cfg.fileserverHits.Add(1)
		// Continue to the next handler in the chain
		next.ServeHTTP(w, r)
	})
}

// handlerCreateChirp handles POST /api/chirps - creates a new chirp message.
// This endpoint requires JWT authentication and validates the chirp content
// before storing it in the database.
//
// Request: JSON body with "body" field containing the chirp text
// Authentication: Bearer token in Authorization header
// Validation: Maximum 140 characters, profanity filtering
//
// PRODUCTION IMPROVEMENTS:
// - Add rate limiting per user
// - Implement content moderation
// - Add request validation middleware
// - Use structured logging with request IDs
// - Add metrics for chirp creation rates
func (cfg *apiConfig) handlerCreateChirp(w http.ResponseWriter, r *http.Request) {
	// Decode JSON request body into database parameters struct
	decoder := json.NewDecoder(r.Body)
	params := database.CreateChirpParams{}
	err := decoder.Decode(&params)
	if err != nil {
		log.Printf("Error decoding parameters: %s", err.Error())
		marshallError(w, err, 500)
		return
	}

	// Extract and validate JWT token from Authorization header
	bearerToken, err := auth.GetBearerToken(r.Header)
	if err != nil {
		log.Printf("Error getting bearer token: %s", err.Error())
		marshallError(w, err, 401)
		return
	}

	// Validate JWT token and extract user ID
	userId, err := auth.ValidateJWT(bearerToken, cfg.secretKey)
	if err != nil {
		log.Printf("Error validating bearer token: %s", err.Error())
		marshallError(w, err, 401)
		return
	}

	// Validate chirp content (length and profanity filtering)
	respBody, err := validate(params)
	if err != nil {
		log.Printf("Error validating chirp: %s", err.Error())
		marshallError(w, err, 400)
		return
	}

	// Create chirp in database with authenticated user ID
	chirp, err := cfg.databaseQueries.CreateChirp(r.Context(), database.CreateChirpParams{Body: respBody, UserID: userId})
	if err != nil {
		log.Printf("Error creating chirp: %s", err.Error())
		marshallError(w, err, 500)
		return
	}

	// Prepare response structure
	type response struct {
		ID     uuid.UUID `json:"id"`
		Body   string    `json:"body"`
		UserID uuid.UUID `json:"user_id"`
	}
	resp := response{
		ID:     chirp.ID,
		Body:   respBody,
		UserID: userId,
	}

	// Marshal response to JSON and send to client
	dat, err := json.Marshal(resp)
	if err != nil {
		log.Printf("Error marshalling response body: %s", err.Error())
		marshallError(w, err, 500)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201) // Created
	w.Write(dat)
}

// validate performs content validation on chirp messages.
// Enforces the 140-character limit (like early Twitter) and filters profanity.
//
// PRODUCTION IMPROVEMENTS:
// - Use a proper content moderation service
// - Add configurable character limits
// - Implement more sophisticated profanity detection
// - Add support for multiple languages
// - Consider using external APIs for content analysis
func validate(params database.CreateChirpParams) (string, error) {
	// Enforce character limit
	if len(params.Body) > 140 {
		return "", fmt.Errorf("chirp is too long")
	}

	// Clean profanity and return sanitized content
	respBody := cleanString(params.Body)
	return respBody, nil
}

// marshallError is a helper function for consistent error response formatting.
// Creates standardized JSON error responses with appropriate HTTP status codes.
//
// PRODUCTION IMPROVEMENTS:
// - Add error codes for client-side error handling
// - Include request ID for debugging
// - Add structured error details
// - Implement error categorization (client vs server errors)
// - Add localization support for error messages
func marshallError(w http.ResponseWriter, err error, code int) {
	type errorResponse struct {
		Error string `json:"error"`
	}

	w.WriteHeader(code)
	dat, err := json.Marshal(errorResponse{
		Error: err.Error(),
	})
	if err != nil {
		log.Printf("Error marshalling error response: %s", err.Error())
		return
	}
	w.Write(dat)
}

// cleanString performs basic profanity filtering on text content.
// Replaces predefined "bad" words with asterisks.
//
// PRODUCTION IMPROVEMENTS:
// - Use a comprehensive profanity database
// - Implement context-aware filtering
// - Add support for multiple languages
// - Consider using machine learning for content moderation
// - Make the word list configurable
// - Add bypass mechanisms for legitimate use cases
func cleanString(s string) string {
	var result string
	words := strings.Split(s, " ")
	
	// List of words to filter (expand this in production)
	bannedWords := []string{"kerfuffle", "sharbert", "fornax"}
	
	for _, word := range words {
		wordLower := strings.ToLower(word)
		isBanned := false
		
		for _, banned := range bannedWords {
			if wordLower == banned {
				word = "****"
				isBanned = true
				break
			}
		}
		
		result += word + " "
	}
	
	return strings.TrimRight(result, " ")
}

// handlerCreateChirp handles POST /api/chirps - creates a new chirp message.
// This endpoint requires JWT authentication and validates the chirp content
// before storing it in the database.
//
// Request: JSON body with "body" field containing the chirp text
// Authentication: Bearer token in Authorization header
// Validation: Maximum 140 characters, profanity filtering
//
// PRODUCTION IMPROVEMENTS:
// - Add rate limiting per user
// - Implement content moderation
// - Add request validation middleware
// - Use structured logging with request IDs
// - Add metrics for chirp creation rates
func (cfg *apiConfig) handlerCreateChirp(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerGetChirps handles GET /api/chirps - retrieves chirps with optional filtering.
// Supports query parameters for author filtering and sorting.
//
// Query Parameters:
//   - author_id: Filter chirps by specific user UUID
//   - sort: "desc" for newest first, omit for oldest first
//
// PRODUCTION IMPROVEMENTS:
// - Implement pagination for large datasets
// - Add caching for frequently accessed chirps
// - Add full-text search capabilities
// - Implement proper error handling for invalid UUIDs
func (cfg *apiConfig) handlerGetChirps(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerGetChirpById handles GET /api/chirps/{chirpID} - retrieves a specific chirp.
// Returns 404 if chirp doesn't exist.
//
// Path Parameters:
//   - chirpID: UUID of the chirp to retrieve
//
// PRODUCTION IMPROVEMENTS:
// - Add caching for individual chirp lookups
// - Implement view tracking/analytics
// - Add proper error differentiation (not found vs server error)
func (cfg *apiConfig) handlerGetChirpById(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerDeleteChirp handles DELETE /api/chirps/{chirpID} - deletes a chirp.
// Only the chirp author can delete their own chirps.
//
// Authentication: Bearer token in Authorization header
// Authorization: Must be the chirp author
//
// PRODUCTION IMPROVEMENTS:
// - Implement soft deletes for data recovery
// - Add audit logging for deletion events
// - Consider implementing admin override capabilities
func (cfg *apiConfig) handlerDeleteChirp(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerLogin handles POST /api/login - authenticates users and returns tokens.
// Validates credentials and returns both access and refresh tokens.
//
// Request: JSON with email and password
// Response: User data with JWT and refresh tokens
//
// PRODUCTION IMPROVEMENTS:
// - Implement account lockout after failed attempts
// - Add login attempt logging and monitoring
// - Implement device/session tracking
// - Add two-factor authentication support
func (cfg *apiConfig) handlerLogin(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerRegister handles POST /api/users - creates new user accounts.
// Only available in development mode for security.
//
// Request: JSON with email and password
// Environment: Only works when PLATFORM=dev
//
// PRODUCTION IMPROVEMENTS:
// - Implement proper user registration flow
// - Add email verification
// - Implement invitation-based registration
// - Add CAPTCHA protection
func (cfg *apiConfig) handlerRegister(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerPutUsers handles PUT /api/users - updates user account information.
// Allows users to update their email and password.
//
// Authentication: Bearer token in Authorization header
// Authorization: Users can only update their own accounts
//
// PRODUCTION IMPROVEMENTS:
// - Implement email change verification
// - Add password strength requirements
// - Implement profile picture uploads
// - Add account deactivation options
func (cfg *apiConfig) handlerPutUsers(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerRefresh handles POST /api/refresh - refreshes JWT access tokens.
// Uses refresh tokens to generate new short-lived access tokens.
//
// Authentication: Refresh token in Authorization header
//
// PRODUCTION IMPROVEMENTS:
// - Implement token rotation (invalidate old refresh token)
// - Add device tracking and management
// - Implement suspicious activity detection
// - Add token family tracking for security
func (cfg *apiConfig) handlerRefresh(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerRevoke handles POST /api/revoke - revokes refresh tokens.
// Invalidates refresh tokens for logout functionality.
//
// Authentication: Refresh token in Authorization header
//
// PRODUCTION IMPROVEMENTS:
// - Implement "logout all devices" functionality
// - Add session management UI
// - Implement automatic token cleanup
func (cfg *apiConfig) handlerRevoke(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// handlerPolkaWebhook handles POST /api/polka/webhooks - processes payment webhooks.
// Upgrades users to premium status when payment is confirmed.
//
// Request: JSON with event type and user data
// Authentication: Webhook signature validation (if implemented)
//
// PRODUCTION IMPROVEMENTS:
// - Implement webhook signature validation
// - Add idempotency handling for duplicate webhooks
// - Implement proper error handling and retry logic
// - Add webhook event logging and monitoring
func (cfg *apiConfig) handlerPolkaWebhook(w http.ResponseWriter, r *http.Request) {
	// Implementation details...
}

// validate performs content validation on chirp messages.
// Enforces the 140-character limit and filters profanity.
//
// PRODUCTION IMPROVEMENTS:
// - Use a proper content moderation service
// - Add configurable character limits
// - Implement more sophisticated profanity detection
// - Add support for multiple languages
func validate(params database.CreateChirpParams) (string, error) {
	// Implementation details...
}

// cleanString performs basic profanity filtering on text content.
// Replaces predefined "bad" words with asterisks.
//
// PRODUCTION IMPROVEMENTS:
// - Use a comprehensive profanity database
// - Implement context-aware filtering
// - Add support for multiple languages
// - Consider using machine learning for content moderation
func cleanString(s string) string {
	// Implementation details...
}